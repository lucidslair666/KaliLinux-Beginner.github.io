一些看了一些关于秘密扫描的基础知识,有一些体会

首先是对TCP层的一些认识.
在TCP层有几个FLAGS字段,该字段有以下几个标识
SYN			FIN			ACK			PSH		 	  RST			URG                 
建立连接	关闭连接	响应	  有DATA数据传输  	连接重置	紧急标志置位

Connect扫描
	试图与对端主机的每一个TCP端口进行三次握手通信,若建立连接则对端端口开放.很危险也很笨拙
	很容易被防火墙和IDS检测到,并且在目标主机的日志中记录了大量的连接请求以及错误信息
	
	IDS  : 入侵检测系统,发现违反安全策略的网络传输是IDS的核心


TCP扫描便是根据以上几种标识符来进行的
	普通TCP扫描,一般来说他的速度较慢,因为本机和对端之间要尝试建立连接
	
	SYN扫描
		速度较快
		向目标主机端口发送一个SYN数据段,表示请求建立连接.然后再发送一个RST数据段给目标主机端口,表示拒绝建立连接.根据目标主机回应的报文来判断对端端口是否开启
		若对端端口回应 SYN = 1 , ACK = 1,则表示对端端口开放
		若对端端口回应 RST ,则表示对端端口关闭
		
	FIN扫描
		向目标主机端口发送一个FIN数据段
		若对端端口回应 RST ,则表示对端端口关闭
		若对端端口无任何回应,则表示对端端口开放
		
	ACK扫描*
		向目标主机端口发送ACK数据段,根据返回的RST数据包来得到对端端口信息
		若对端端口返回的RST数据包的TTL值小于或者等于64,则端口开放,
		反之,则端口关闭
		有时则不可以判断对端端口是开启还是关闭的,需要具体实践!!!
		
	NULL扫描 (可辨别对端操作系统)
		将一个没有设置任何标志位的数据包发送给TCP端口
		根据RFC 793要求,在端口关闭情况下,收到一个没有设置标志位的数据字段,则主机应该舍弃这个分段,并且返回一个RST数据包
		若对端端口返回 RST ,则对端端口关闭
		若对端端口无响应,则对端端口开放
		注意 : NULL扫描只针对Unix系统有效,对WIndows系统无效,因为Windows系统不遵从RFC 793标准,无论端口开启还是关闭,在收到无标志位的数据包时都将返回 RST包,所以使用NULL扫描还可以判断对端操作系统,是Windows还是Unix.
		
	Xmas-Tree扫描
		在Xmas-Tree扫描中需要用到TCP中的另外几个标志位
		URG	PSH	FIN
		指示数据时紧急数据	推置位	结束TCP会话
			强制将数据压入缓冲区
			不将数据进行队列处理,
			而是尽可能快的将数据
			转由应用处理,
		
		正常情况下,这三个标志位不能同时被设置,但是这种扫描可以用来判断哪些端口开放,哪些端口关闭.依旧不能用于判断Windows平台上的端口
		对于Unix操作系统
		端口开放 : 发送URG/PSH/FIN数据段,没有响应
		端口关闭 : 发送URG/PSH/FIN数据段,收到RST回应
		
	Dump扫描
		也被称为idle扫描或者反向扫描,在扫描对端主机时使用了第三方僵尸计算机,
		僵尸主机想目标发送SYN包,对端开放时会回应SYN|ACK,对端关闭时会回应RST,僵尸主机对SYN|ACK做RST回应,对RST不做回应/
		从僵尸主机上进行扫描时,是一个从本地主机到僵尸主机,连续的Ping的过程.
		查看僵尸主机返回的ECHO响应的ID字段,能确定目标主机上的哪些端口是开放的
		
		僵尸计算机 : 肉鸡,可以随时按照操控者的命令与控制(C&C来展开拒绝服务攻击(DOS攻击)或者发送垃圾信息,隐蔽性较高.
		
	
个人感觉,目前常见的秘密端口扫描主要是在TCP连接上做文章,相比于正常的三次握手建立TCP连接,秘密端口扫描往往是作用于TCP的FLAGS字段,他没有包含完整的三次握手的过程,所以无法被对端主机记录下来.它可以躲避IDS,防火墙,包过滤器和日志审计,从而获得对端口的状态,是开放还是关闭.某些特定的扫描方式例如Null扫描和Xmas-Tree扫描,还可以判断对端的操作系统.
